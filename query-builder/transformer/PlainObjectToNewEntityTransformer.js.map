{"version":3,"sources":["../../src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts"],"names":[],"mappings":"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","file":"PlainObjectToNewEntityTransformer.js","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T>(newEntity: T, object: ObjectLiteral, metadata: EntityMetadata, getLazyRelationsPromiseValue: boolean = false): T {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);\n        // console.log(\"result:\", newEntity);\n        return newEntity;\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(entity: ObjectLiteral, object: ObjectLiteral, metadata: EntityMetadata, getLazyRelationsPromiseValue: boolean = false): void {\n\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach(column => {\n            const objectColumnValue = column.getEntityValue(object);\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue);\n        });\n\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach(relation => {\n\n                let entityRelatedValue = relation.getEntityValue(entity);\n                const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n                if (objectRelatedValue === undefined)\n                    return;\n\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!(objectRelatedValue instanceof Array))\n                        return;\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = [];\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n\n                    objectRelatedValue.forEach(objectRelatedValueItem => {\n\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = (entityRelatedValue as any[]).find(entityRelatedValueItem => {\n                            return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n                        });\n\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity = relation.inverseEntityMetadata.create();\n                            entityRelatedValue.push(objectRelatedValueEntity);\n                        }\n\n                        this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n                    });\n\n                } else {\n\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!(objectRelatedValue instanceof Object)) {\n                        if (!(entityRelatedValue instanceof Object))\n                            relation.setEntityValue(entity, objectRelatedValue);\n                        return;\n                    }\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = relation.inverseEntityMetadata.create();\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n\n                    this.groupAndTransform(entityRelatedValue, objectRelatedValue, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n                }\n            });\n        }\n    }\n\n}"],"sourceRoot":"../.."}