{"version":3,"sources":["../../src/persistence/SubjectDatabaseEntityLoader.ts"],"names":[],"mappings":"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","file":"SubjectDatabaseEntityLoader.js","sourcesContent":["import {Subject} from \"./Subject\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(operationType: \"save\"|\"remove\"): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds: ObjectLiteral[] = [];\n            subjectGroup.subjects.forEach(subject => {\n\n                // we don't load if subject already has a database entity loaded\n                if (subject.databaseEntity)\n                    return;\n\n                // we only need entity id\n                if (subject.metadata.isEntityIdMapEmpty(subject.entity!)) // can we use getEntityIdMap instead\n                    return;\n\n                allIds.push(subject.metadata.getEntityIdMap(subject.entity!)!);\n            });\n\n            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n\n            const loadRelationPropertyPaths: string[] = [];\n\n            // for the save operation\n            // extract all property paths of the relations we need to load relation ids for\n            // this is for optimization purpose - this way we don't load relation ids for entities\n            // whose relations are undefined, and since they are undefined its really pointless to\n            // load something for them, since undefined properties are skipped by the orm\n            if (operationType === \"save\") {\n                subjectGroup.subjects.forEach(subject => {\n\n                    // gets all relation property paths that exist in the persisted entity.\n                    subject.metadata.relations\n                        .filter(relation => relation.getEntityValue(subject.entity!) !== undefined)\n                        .map(relation => relation.propertyPath)\n                        .forEach(propertyPath => {\n                            if (loadRelationPropertyPaths.indexOf(propertyPath) === -1)\n                                loadRelationPropertyPaths.push(propertyPath);\n                        });\n                });\n            } else { // remove\n\n                // for remove operation\n                // we only need to load junction relation ids since only they are removed by cascades\n                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n            }\n\n            const findOptions: FindManyOptions<any> = {\n                loadRelationIds: {\n                    relations: loadRelationPropertyPaths,\n                    disableMixedMap: true\n                }\n            };\n\n            // load database entities for all given ids\n            const entities = await this.queryRunner.manager\n                .getRepository<ObjectLiteral>(subjectGroup.target)\n                .findByIds(allIds, findOptions);\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subject\n            entities.forEach(entity => {\n                const subject = this.findByPersistEntityLike(subjectGroup.target, entity);\n                if (subject) {\n                    subject.databaseEntity = entity;\n                    if (!subject.identifier)\n                        subject.identifier = subject.metadata.isEntityIdMapEmpty(entity) ? undefined : subject.metadata.getEntityIdMap(entity);\n                }\n            });\n\n        });\n\n        await Promise.all(promises);\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparision made by entity id.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.subjects.find(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entity, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.metadata.target);\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}"],"sourceRoot":".."}