{"version":3,"sources":["../browser/src/persistence/SubjectExecutor.ts"],"names":[],"mappings":"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","file":"SubjectExecutor.js","sourcesContent":["import {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Subject} from \"./Subject\";\nimport {PromiseUtils} from \"../util/PromiseUtils\";\nimport {SubjectTopoligicalSorter} from \"./SubjectTopoligicalSorter\";\nimport {SubjectChangedColumnsComputer} from \"./SubjectChangedColumnsComputer\";\nimport {SubjectWithoutIdentifierError} from \"../error/SubjectWithoutIdentifierError\";\nimport {SubjectRemovedAndUpdatedError} from \"../error/SubjectRemovedAndUpdatedError\";\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner;\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions;\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[];\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(queryRunner: QueryRunner, subjects: Subject[], options?: SaveOptions & RemoveOptions) {\n        this.queryRunner = queryRunner;\n        this.allSubjects = subjects;\n        this.options = options;\n        this.validate();\n        this.recompute();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult|undefined = undefined;\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.recompute();\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n        await this.executeInsertOperations();\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations();\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n        await this.executeRemoveOperations();\n        // console.timeEnd(\".removal\");\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities();\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach(subject => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject);\n        });\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\n        this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n        this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0;\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        return result;\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        return result;\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        await PromiseUtils.runInSequence(groupedInsertSubjectKeys, async groupName => {\n            const subjects = groupedInsertSubjects[groupName];\n            const insertMaps = subjects.map(subject => {\n                if (this.queryRunner.connection.driver instanceof MongoDriver) {\n                    return subject.entity;\n                } else {\n                    return subject.createValueSetAndPopChangeMap();\n                }\n            });\n            let insertResult: InsertResult;\n\n            // for mongodb we have a bit different insertion logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                insertResult = await manager.insert(subjects[0].metadata.target, insertMaps);\n\n            } else {\n\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                insertResult = await this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .insert()\n                    .into(subjects[0].metadata.target)\n                    .values(insertMaps)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false)\n                    .execute();\n            }\n\n            subjects.forEach((subject, index) => {\n                subject.identifier = insertResult.identifiers[index];\n                subject.generatedMap = insertResult.generatedMaps[index];\n                subject.insertedValueSet = insertMaps[index];\n            });\n        });\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        await Promise.all(this.updateSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            const updateMap: ObjectLiteral = this.queryRunner.connection.driver instanceof MongoDriver ? subject.entity! : subject.createValueSetAndPopChangeMap();\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                await manager.update(subject.metadata.target, subject.identifier, updateMap);\n\n            } else {\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await updateQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n            }\n        }));\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n\n        await PromiseUtils.runInSequence(groupedRemoveSubjectKeys, async groupName => {\n            const subjects = groupedRemoveSubjects[groupName];\n            const deleteMaps = subjects.map(subject => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject);\n\n                return subject.identifier;\n            });\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\n\n            } else {\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute();\n            }\n        });\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach(subject => {\n                if (!subject.entity) return;\n\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined);\n                });\n            });\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            subject.metadata.relationIds.forEach(relationId => {\n                relationId.setValue(subject.entity!);\n            });\n        });\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(subjects: Subject[]): void {\n        subjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach(column => {\n                if (!column.isNullable || column.isVirtual)\n                    return;\n\n                const columnValue = column.getEntityValue(subject.entity!);\n                if (columnValue === undefined)\n                    column.setEntityValue(subject.entity!, null);\n            });\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n        });\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(subjects: Subject[], type: \"insert\"|\"delete\"): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {};\n        const keys: string[] = [];\n        const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        subjects.forEach((subject, index) => {\n            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n            if (!group[key]) {\n                group[key] = [subject];\n                keys.push(key);\n            } else {\n                group[key].push(subject);\n            }\n        });\n\n        return [group, keys];\n    }\n\n}\n"],"sourceRoot":".."}